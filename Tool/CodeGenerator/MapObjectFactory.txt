template<typename TId, typename TBase  , typename THashCoder,bool IsPoolEnabled> class MapObjectFactory<TId,TBase*(),THashCoder,IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback(); typedef CreateDerivedCallback* CreatorType; ~MapObjectFactory(){Clear();} private: typedef Dictionary<TId,CreatorType,THashCoder> MapType; typedef Stack<TBase*> ObjectPool; typedef Dictionary<TId,ObjectPool*,THashCoder> ObjectPoolDict; MapType mMap; ObjectPoolDict mPoolDict; template<typename TDerived> static TBase* CreateDerivedHelper() { return new TDerived(); } public: template<typename TDerived> void Register(const TId& id){mMap.Add(id,&CreateDerivedHelper<TDerived>);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} void Register(const TId& id,CreatorType creator){mMap.Add(id,creator);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} template<typename TDerived> bool TryRegister(const TId& id){if(mMap.TryAdd(id,&CreateDerivedHelper<TDerived>)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());} return true;}return false;} bool TryRegister(const TId& id,CreatorType creator){if(mMap.TryAdd(id,creator)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}return true;}return false;;} bool UnRegister(const TId& id){if(IsPoolEnabled){ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0);if(objectPool!=0){{for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();};delete objectPool;}} return mMap.RemoveKey(id);} TBase* Create(const TId& id  ) { if(IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if(objectPool!=0&&!objectPool->IsEmpty()) { return objectPool->Pop(); } } CreatorType* outCreator=mMap.TryGetValue(id); if(outCreator!=0) { return (*outCreator)(); } return 0; } void Recycle(const TId& id,TBase* obj) { if (IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if (objectPool != 0) { objectPool->Push(obj); } } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(auto i = (mPoolDict).GetEnumerator();i.MoveNext();) { ObjectPool* objectPool = i->Value; {for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();}; delete objectPool; } mPoolDict.Clear(); } };
template<typename TId, typename TBase ,  typename T1, typename THashCoder,bool IsPoolEnabled> class MapObjectFactory<TId,TBase*( T1 p1),THashCoder,IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1); typedef CreateDerivedCallback* CreatorType; ~MapObjectFactory(){Clear();} private: typedef Dictionary<TId,CreatorType,THashCoder> MapType; typedef Stack<TBase*> ObjectPool; typedef Dictionary<TId,ObjectPool*,THashCoder> ObjectPoolDict; MapType mMap; ObjectPoolDict mPoolDict; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1) { return new TDerived( p1); } public: template<typename TDerived> void Register(const TId& id){mMap.Add(id,&CreateDerivedHelper<TDerived>);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} void Register(const TId& id,CreatorType creator){mMap.Add(id,creator);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} template<typename TDerived> bool TryRegister(const TId& id){if(mMap.TryAdd(id,&CreateDerivedHelper<TDerived>)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());} return true;}return false;} bool TryRegister(const TId& id,CreatorType creator){if(mMap.TryAdd(id,creator)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}return true;}return false;;} bool UnRegister(const TId& id){if(IsPoolEnabled){ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0);if(objectPool!=0){{for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();};delete objectPool;}} return mMap.RemoveKey(id);} TBase* Create(const TId& id ,  T1 p1) { if(IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if(objectPool!=0&&!objectPool->IsEmpty()) { return objectPool->Pop(); } } CreatorType* outCreator=mMap.TryGetValue(id); if(outCreator!=0) { return (*outCreator)( p1); } return 0; } void Recycle(const TId& id,TBase* obj) { if (IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if (objectPool != 0) { objectPool->Push(obj); } } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(auto i = (mPoolDict).GetEnumerator();i.MoveNext();) { ObjectPool* objectPool = i->Value; {for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();}; delete objectPool; } mPoolDict.Clear(); } };
template<typename TId, typename TBase ,  typename T1, typename T2, typename THashCoder,bool IsPoolEnabled> class MapObjectFactory<TId,TBase*( T1 p1, T2 p2),THashCoder,IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1, T2 p2); typedef CreateDerivedCallback* CreatorType; ~MapObjectFactory(){Clear();} private: typedef Dictionary<TId,CreatorType,THashCoder> MapType; typedef Stack<TBase*> ObjectPool; typedef Dictionary<TId,ObjectPool*,THashCoder> ObjectPoolDict; MapType mMap; ObjectPoolDict mPoolDict; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1, T2 p2) { return new TDerived( p1, p2); } public: template<typename TDerived> void Register(const TId& id){mMap.Add(id,&CreateDerivedHelper<TDerived>);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} void Register(const TId& id,CreatorType creator){mMap.Add(id,creator);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} template<typename TDerived> bool TryRegister(const TId& id){if(mMap.TryAdd(id,&CreateDerivedHelper<TDerived>)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());} return true;}return false;} bool TryRegister(const TId& id,CreatorType creator){if(mMap.TryAdd(id,creator)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}return true;}return false;;} bool UnRegister(const TId& id){if(IsPoolEnabled){ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0);if(objectPool!=0){{for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();};delete objectPool;}} return mMap.RemoveKey(id);} TBase* Create(const TId& id ,  T1 p1, T2 p2) { if(IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if(objectPool!=0&&!objectPool->IsEmpty()) { return objectPool->Pop(); } } CreatorType* outCreator=mMap.TryGetValue(id); if(outCreator!=0) { return (*outCreator)( p1, p2); } return 0; } void Recycle(const TId& id,TBase* obj) { if (IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if (objectPool != 0) { objectPool->Push(obj); } } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(auto i = (mPoolDict).GetEnumerator();i.MoveNext();) { ObjectPool* objectPool = i->Value; {for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();}; delete objectPool; } mPoolDict.Clear(); } };
template<typename TId, typename TBase ,  typename T1, typename T2, typename T3, typename THashCoder,bool IsPoolEnabled> class MapObjectFactory<TId,TBase*( T1 p1, T2 p2, T3 p3),THashCoder,IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1, T2 p2, T3 p3); typedef CreateDerivedCallback* CreatorType; ~MapObjectFactory(){Clear();} private: typedef Dictionary<TId,CreatorType,THashCoder> MapType; typedef Stack<TBase*> ObjectPool; typedef Dictionary<TId,ObjectPool*,THashCoder> ObjectPoolDict; MapType mMap; ObjectPoolDict mPoolDict; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1, T2 p2, T3 p3) { return new TDerived( p1, p2, p3); } public: template<typename TDerived> void Register(const TId& id){mMap.Add(id,&CreateDerivedHelper<TDerived>);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} void Register(const TId& id,CreatorType creator){mMap.Add(id,creator);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} template<typename TDerived> bool TryRegister(const TId& id){if(mMap.TryAdd(id,&CreateDerivedHelper<TDerived>)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());} return true;}return false;} bool TryRegister(const TId& id,CreatorType creator){if(mMap.TryAdd(id,creator)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}return true;}return false;;} bool UnRegister(const TId& id){if(IsPoolEnabled){ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0);if(objectPool!=0){{for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();};delete objectPool;}} return mMap.RemoveKey(id);} TBase* Create(const TId& id ,  T1 p1, T2 p2, T3 p3) { if(IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if(objectPool!=0&&!objectPool->IsEmpty()) { return objectPool->Pop(); } } CreatorType* outCreator=mMap.TryGetValue(id); if(outCreator!=0) { return (*outCreator)( p1, p2, p3); } return 0; } void Recycle(const TId& id,TBase* obj) { if (IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if (objectPool != 0) { objectPool->Push(obj); } } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(auto i = (mPoolDict).GetEnumerator();i.MoveNext();) { ObjectPool* objectPool = i->Value; {for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();}; delete objectPool; } mPoolDict.Clear(); } };
template<typename TId, typename TBase ,  typename T1, typename T2, typename T3, typename T4, typename THashCoder,bool IsPoolEnabled> class MapObjectFactory<TId,TBase*( T1 p1, T2 p2, T3 p3, T4 p4),THashCoder,IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1, T2 p2, T3 p3, T4 p4); typedef CreateDerivedCallback* CreatorType; ~MapObjectFactory(){Clear();} private: typedef Dictionary<TId,CreatorType,THashCoder> MapType; typedef Stack<TBase*> ObjectPool; typedef Dictionary<TId,ObjectPool*,THashCoder> ObjectPoolDict; MapType mMap; ObjectPoolDict mPoolDict; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1, T2 p2, T3 p3, T4 p4) { return new TDerived( p1, p2, p3, p4); } public: template<typename TDerived> void Register(const TId& id){mMap.Add(id,&CreateDerivedHelper<TDerived>);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} void Register(const TId& id,CreatorType creator){mMap.Add(id,creator);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} template<typename TDerived> bool TryRegister(const TId& id){if(mMap.TryAdd(id,&CreateDerivedHelper<TDerived>)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());} return true;}return false;} bool TryRegister(const TId& id,CreatorType creator){if(mMap.TryAdd(id,creator)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}return true;}return false;;} bool UnRegister(const TId& id){if(IsPoolEnabled){ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0);if(objectPool!=0){{for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();};delete objectPool;}} return mMap.RemoveKey(id);} TBase* Create(const TId& id ,  T1 p1, T2 p2, T3 p3, T4 p4) { if(IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if(objectPool!=0&&!objectPool->IsEmpty()) { return objectPool->Pop(); } } CreatorType* outCreator=mMap.TryGetValue(id); if(outCreator!=0) { return (*outCreator)( p1, p2, p3, p4); } return 0; } void Recycle(const TId& id,TBase* obj) { if (IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if (objectPool != 0) { objectPool->Push(obj); } } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(auto i = (mPoolDict).GetEnumerator();i.MoveNext();) { ObjectPool* objectPool = i->Value; {for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();}; delete objectPool; } mPoolDict.Clear(); } };
template<typename TId, typename TBase ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename THashCoder,bool IsPoolEnabled> class MapObjectFactory<TId,TBase*( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5),THashCoder,IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5); typedef CreateDerivedCallback* CreatorType; ~MapObjectFactory(){Clear();} private: typedef Dictionary<TId,CreatorType,THashCoder> MapType; typedef Stack<TBase*> ObjectPool; typedef Dictionary<TId,ObjectPool*,THashCoder> ObjectPoolDict; MapType mMap; ObjectPoolDict mPoolDict; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5) { return new TDerived( p1, p2, p3, p4, p5); } public: template<typename TDerived> void Register(const TId& id){mMap.Add(id,&CreateDerivedHelper<TDerived>);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} void Register(const TId& id,CreatorType creator){mMap.Add(id,creator);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} template<typename TDerived> bool TryRegister(const TId& id){if(mMap.TryAdd(id,&CreateDerivedHelper<TDerived>)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());} return true;}return false;} bool TryRegister(const TId& id,CreatorType creator){if(mMap.TryAdd(id,creator)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}return true;}return false;;} bool UnRegister(const TId& id){if(IsPoolEnabled){ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0);if(objectPool!=0){{for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();};delete objectPool;}} return mMap.RemoveKey(id);} TBase* Create(const TId& id ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5) { if(IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if(objectPool!=0&&!objectPool->IsEmpty()) { return objectPool->Pop(); } } CreatorType* outCreator=mMap.TryGetValue(id); if(outCreator!=0) { return (*outCreator)( p1, p2, p3, p4, p5); } return 0; } void Recycle(const TId& id,TBase* obj) { if (IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if (objectPool != 0) { objectPool->Push(obj); } } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(auto i = (mPoolDict).GetEnumerator();i.MoveNext();) { ObjectPool* objectPool = i->Value; {for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();}; delete objectPool; } mPoolDict.Clear(); } };
template<typename TId, typename TBase ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename THashCoder,bool IsPoolEnabled> class MapObjectFactory<TId,TBase*( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6),THashCoder,IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6); typedef CreateDerivedCallback* CreatorType; ~MapObjectFactory(){Clear();} private: typedef Dictionary<TId,CreatorType,THashCoder> MapType; typedef Stack<TBase*> ObjectPool; typedef Dictionary<TId,ObjectPool*,THashCoder> ObjectPoolDict; MapType mMap; ObjectPoolDict mPoolDict; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6) { return new TDerived( p1, p2, p3, p4, p5, p6); } public: template<typename TDerived> void Register(const TId& id){mMap.Add(id,&CreateDerivedHelper<TDerived>);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} void Register(const TId& id,CreatorType creator){mMap.Add(id,creator);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} template<typename TDerived> bool TryRegister(const TId& id){if(mMap.TryAdd(id,&CreateDerivedHelper<TDerived>)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());} return true;}return false;} bool TryRegister(const TId& id,CreatorType creator){if(mMap.TryAdd(id,creator)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}return true;}return false;;} bool UnRegister(const TId& id){if(IsPoolEnabled){ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0);if(objectPool!=0){{for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();};delete objectPool;}} return mMap.RemoveKey(id);} TBase* Create(const TId& id ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6) { if(IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if(objectPool!=0&&!objectPool->IsEmpty()) { return objectPool->Pop(); } } CreatorType* outCreator=mMap.TryGetValue(id); if(outCreator!=0) { return (*outCreator)( p1, p2, p3, p4, p5, p6); } return 0; } void Recycle(const TId& id,TBase* obj) { if (IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if (objectPool != 0) { objectPool->Push(obj); } } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(auto i = (mPoolDict).GetEnumerator();i.MoveNext();) { ObjectPool* objectPool = i->Value; {for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();}; delete objectPool; } mPoolDict.Clear(); } };
template<typename TId, typename TBase ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename THashCoder,bool IsPoolEnabled> class MapObjectFactory<TId,TBase*( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7),THashCoder,IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7); typedef CreateDerivedCallback* CreatorType; ~MapObjectFactory(){Clear();} private: typedef Dictionary<TId,CreatorType,THashCoder> MapType; typedef Stack<TBase*> ObjectPool; typedef Dictionary<TId,ObjectPool*,THashCoder> ObjectPoolDict; MapType mMap; ObjectPoolDict mPoolDict; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7) { return new TDerived( p1, p2, p3, p4, p5, p6, p7); } public: template<typename TDerived> void Register(const TId& id){mMap.Add(id,&CreateDerivedHelper<TDerived>);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} void Register(const TId& id,CreatorType creator){mMap.Add(id,creator);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} template<typename TDerived> bool TryRegister(const TId& id){if(mMap.TryAdd(id,&CreateDerivedHelper<TDerived>)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());} return true;}return false;} bool TryRegister(const TId& id,CreatorType creator){if(mMap.TryAdd(id,creator)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}return true;}return false;;} bool UnRegister(const TId& id){if(IsPoolEnabled){ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0);if(objectPool!=0){{for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();};delete objectPool;}} return mMap.RemoveKey(id);} TBase* Create(const TId& id ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7) { if(IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if(objectPool!=0&&!objectPool->IsEmpty()) { return objectPool->Pop(); } } CreatorType* outCreator=mMap.TryGetValue(id); if(outCreator!=0) { return (*outCreator)( p1, p2, p3, p4, p5, p6, p7); } return 0; } void Recycle(const TId& id,TBase* obj) { if (IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if (objectPool != 0) { objectPool->Push(obj); } } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(auto i = (mPoolDict).GetEnumerator();i.MoveNext();) { ObjectPool* objectPool = i->Value; {for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();}; delete objectPool; } mPoolDict.Clear(); } };
template<typename TId, typename TBase ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename THashCoder,bool IsPoolEnabled> class MapObjectFactory<TId,TBase*( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8),THashCoder,IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8); typedef CreateDerivedCallback* CreatorType; ~MapObjectFactory(){Clear();} private: typedef Dictionary<TId,CreatorType,THashCoder> MapType; typedef Stack<TBase*> ObjectPool; typedef Dictionary<TId,ObjectPool*,THashCoder> ObjectPoolDict; MapType mMap; ObjectPoolDict mPoolDict; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8) { return new TDerived( p1, p2, p3, p4, p5, p6, p7, p8); } public: template<typename TDerived> void Register(const TId& id){mMap.Add(id,&CreateDerivedHelper<TDerived>);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} void Register(const TId& id,CreatorType creator){mMap.Add(id,creator);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} template<typename TDerived> bool TryRegister(const TId& id){if(mMap.TryAdd(id,&CreateDerivedHelper<TDerived>)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());} return true;}return false;} bool TryRegister(const TId& id,CreatorType creator){if(mMap.TryAdd(id,creator)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}return true;}return false;;} bool UnRegister(const TId& id){if(IsPoolEnabled){ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0);if(objectPool!=0){{for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();};delete objectPool;}} return mMap.RemoveKey(id);} TBase* Create(const TId& id ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8) { if(IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if(objectPool!=0&&!objectPool->IsEmpty()) { return objectPool->Pop(); } } CreatorType* outCreator=mMap.TryGetValue(id); if(outCreator!=0) { return (*outCreator)( p1, p2, p3, p4, p5, p6, p7, p8); } return 0; } void Recycle(const TId& id,TBase* obj) { if (IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if (objectPool != 0) { objectPool->Push(obj); } } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(auto i = (mPoolDict).GetEnumerator();i.MoveNext();) { ObjectPool* objectPool = i->Value; {for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();}; delete objectPool; } mPoolDict.Clear(); } };
template<typename TId, typename TBase ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename THashCoder,bool IsPoolEnabled> class MapObjectFactory<TId,TBase*( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9),THashCoder,IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9); typedef CreateDerivedCallback* CreatorType; ~MapObjectFactory(){Clear();} private: typedef Dictionary<TId,CreatorType,THashCoder> MapType; typedef Stack<TBase*> ObjectPool; typedef Dictionary<TId,ObjectPool*,THashCoder> ObjectPoolDict; MapType mMap; ObjectPoolDict mPoolDict; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9) { return new TDerived( p1, p2, p3, p4, p5, p6, p7, p8, p9); } public: template<typename TDerived> void Register(const TId& id){mMap.Add(id,&CreateDerivedHelper<TDerived>);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} void Register(const TId& id,CreatorType creator){mMap.Add(id,creator);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} template<typename TDerived> bool TryRegister(const TId& id){if(mMap.TryAdd(id,&CreateDerivedHelper<TDerived>)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());} return true;}return false;} bool TryRegister(const TId& id,CreatorType creator){if(mMap.TryAdd(id,creator)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}return true;}return false;;} bool UnRegister(const TId& id){if(IsPoolEnabled){ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0);if(objectPool!=0){{for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();};delete objectPool;}} return mMap.RemoveKey(id);} TBase* Create(const TId& id ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9) { if(IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if(objectPool!=0&&!objectPool->IsEmpty()) { return objectPool->Pop(); } } CreatorType* outCreator=mMap.TryGetValue(id); if(outCreator!=0) { return (*outCreator)( p1, p2, p3, p4, p5, p6, p7, p8, p9); } return 0; } void Recycle(const TId& id,TBase* obj) { if (IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if (objectPool != 0) { objectPool->Push(obj); } } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(auto i = (mPoolDict).GetEnumerator();i.MoveNext();) { ObjectPool* objectPool = i->Value; {for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();}; delete objectPool; } mPoolDict.Clear(); } };
template<typename TId, typename TBase ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename THashCoder,bool IsPoolEnabled> class MapObjectFactory<TId,TBase*( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10),THashCoder,IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10); typedef CreateDerivedCallback* CreatorType; ~MapObjectFactory(){Clear();} private: typedef Dictionary<TId,CreatorType,THashCoder> MapType; typedef Stack<TBase*> ObjectPool; typedef Dictionary<TId,ObjectPool*,THashCoder> ObjectPoolDict; MapType mMap; ObjectPoolDict mPoolDict; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10) { return new TDerived( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } public: template<typename TDerived> void Register(const TId& id){mMap.Add(id,&CreateDerivedHelper<TDerived>);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} void Register(const TId& id,CreatorType creator){mMap.Add(id,creator);if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}} template<typename TDerived> bool TryRegister(const TId& id){if(mMap.TryAdd(id,&CreateDerivedHelper<TDerived>)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());} return true;}return false;} bool TryRegister(const TId& id,CreatorType creator){if(mMap.TryAdd(id,creator)){if(IsPoolEnabled){mPoolDict.Add(id,new ObjectPool());}return true;}return false;;} bool UnRegister(const TId& id){if(IsPoolEnabled){ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0);if(objectPool!=0){{for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();};delete objectPool;}} return mMap.RemoveKey(id);} TBase* Create(const TId& id ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10) { if(IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if(objectPool!=0&&!objectPool->IsEmpty()) { return objectPool->Pop(); } } CreatorType* outCreator=mMap.TryGetValue(id); if(outCreator!=0) { return (*outCreator)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } return 0; } void Recycle(const TId& id,TBase* obj) { if (IsPoolEnabled) { ObjectPool* objectPool = mPoolDict.TryGetValueWithFailed(id, 0); if (objectPool != 0) { objectPool->Push(obj); } } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(auto i = (mPoolDict).GetEnumerator();i.MoveNext();) { ObjectPool* objectPool = i->Value; {for(auto i = (*objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(*objectPool).Clear();}; delete objectPool; } mPoolDict.Clear(); } };
