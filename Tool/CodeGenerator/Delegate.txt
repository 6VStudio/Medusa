template<typename R  > class Delegate<R ()> { public: const static Delegate<R ()> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void*  ); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)(); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)()):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)(); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)()const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)()const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke()const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer  ); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()()const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer  ); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func  ) { return (*(TFunc*)obj)(); } static R GlobalWrapper(void * obj,void* func  ) { return ((FunctionType)obj)(); } template<typename TObj> static R MemberWrapper(void * obj,void* func  ) { typedef R (TObj::*large_pointer_to_method)(); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))(); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func  ) { typedef R (TObj::*large_pointer_to_method)()const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))(); } }; template<typename R  > MEDUSA_WEAK_MULTIPLE_DEFINE const Delegate<R ()> Delegate<R ()>::Empty(0);
template<typename R ,  typename T1> class Delegate<R ( T1)> { public: const static Delegate<R ( T1)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1) { return (*(TFunc*)obj)( p1); } static R GlobalWrapper(void * obj,void* func ,  T1 p1) { return ((FunctionType)obj)( p1); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1) { typedef R (TObj::*large_pointer_to_method)( T1); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1) { typedef R (TObj::*large_pointer_to_method)( T1)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1); } }; template<typename R ,  typename T1> MEDUSA_WEAK_MULTIPLE_DEFINE const Delegate<R ( T1)> Delegate<R ( T1)>::Empty(0);
template<typename R ,  typename T1, typename T2> class Delegate<R ( T1, T2)> { public: const static Delegate<R ( T1, T2)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2) { return (*(TFunc*)obj)( p1, p2); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2) { return ((FunctionType)obj)( p1, p2); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2) { typedef R (TObj::*large_pointer_to_method)( T1, T2); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2) { typedef R (TObj::*large_pointer_to_method)( T1, T2)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2); } }; template<typename R ,  typename T1, typename T2> MEDUSA_WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2)> Delegate<R ( T1, T2)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3> class Delegate<R ( T1, T2, T3)> { public: const static Delegate<R ( T1, T2, T3)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3) { return (*(TFunc*)obj)( p1, p2, p3); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3) { return ((FunctionType)obj)( p1, p2, p3); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3); } }; template<typename R ,  typename T1, typename T2, typename T3> MEDUSA_WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3)> Delegate<R ( T1, T2, T3)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4> class Delegate<R ( T1, T2, T3, T4)> { public: const static Delegate<R ( T1, T2, T3, T4)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4) { return (*(TFunc*)obj)( p1, p2, p3, p4); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4) { return ((FunctionType)obj)( p1, p2, p3, p4); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4> MEDUSA_WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4)> Delegate<R ( T1, T2, T3, T4)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5> class Delegate<R ( T1, T2, T3, T4, T5)> { public: const static Delegate<R ( T1, T2, T3, T4, T5)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5) { return ((FunctionType)obj)( p1, p2, p3, p4, p5); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5> MEDUSA_WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5)> Delegate<R ( T1, T2, T3, T4, T5)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> class Delegate<R ( T1, T2, T3, T4, T5, T6)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> MEDUSA_WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6)> Delegate<R ( T1, T2, T3, T4, T5, T6)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> MEDUSA_WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> MEDUSA_WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> MEDUSA_WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> MEDUSA_WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>::Empty(0);
