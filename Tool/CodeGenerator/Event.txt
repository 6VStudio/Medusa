template<typename R  > class Event<R ()> { public: typedef Delegate<R ()> DelegateType; private: List<DelegateType,EqualCompare<DelegateType> > mItems; public: Event(){} Event(const Event& inEvent):mItems(inEvent.mItems){ } public: void Invoke()const { size_t size= mItems.Count(); for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; item.Invoke(); } } List<R> InvokeWithResults()const { size_t size= mItems.Count(); List<R> results; for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; results.Append(item.Invoke()); } return results; } void Clear(){mItems.Clear();} bool IsEmpty()const { return mItems.IsEmpty(); } const List<DelegateType,EqualCompare<DelegateType> >& GetDelegates() const { return mItems; } public: void operator()()const { Invoke(); } void operator+=(const DelegateType& val) { Add(val); } void operator-=(const DelegateType& val) { Remove(val); } Event& operator=(const Event& inEvent) { mItems=inEvent.GetDelegates();return *this; } public: void Add(const DelegateType& val) { if(val.IsValid()){mItems.Append(val);} } void Remove(const DelegateType& val) { mItems.RemoveLast(val); } bool Contains(const DelegateType& val)const { return mItems.Contains(val); } };
template<typename R ,  typename T1> class Event<R ( T1)> { public: typedef Delegate<R ( T1)> DelegateType; private: List<DelegateType,EqualCompare<DelegateType> > mItems; public: Event(){} Event(const Event& inEvent):mItems(inEvent.mItems){ } public: void Invoke( T1 p1)const { size_t size= mItems.Count(); for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; item.Invoke( p1); } } List<R> InvokeWithResults( T1 p1)const { size_t size= mItems.Count(); List<R> results; for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; results.Append(item.Invoke( p1)); } return results; } void Clear(){mItems.Clear();} bool IsEmpty()const { return mItems.IsEmpty(); } const List<DelegateType,EqualCompare<DelegateType> >& GetDelegates() const { return mItems; } public: void operator()( T1 p1)const { Invoke( p1); } void operator+=(const DelegateType& val) { Add(val); } void operator-=(const DelegateType& val) { Remove(val); } Event& operator=(const Event& inEvent) { mItems=inEvent.GetDelegates();return *this; } public: void Add(const DelegateType& val) { if(val.IsValid()){mItems.Append(val);} } void Remove(const DelegateType& val) { mItems.RemoveLast(val); } bool Contains(const DelegateType& val)const { return mItems.Contains(val); } };
template<typename R ,  typename T1, typename T2> class Event<R ( T1, T2)> { public: typedef Delegate<R ( T1, T2)> DelegateType; private: List<DelegateType,EqualCompare<DelegateType> > mItems; public: Event(){} Event(const Event& inEvent):mItems(inEvent.mItems){ } public: void Invoke( T1 p1, T2 p2)const { size_t size= mItems.Count(); for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; item.Invoke( p1, p2); } } List<R> InvokeWithResults( T1 p1, T2 p2)const { size_t size= mItems.Count(); List<R> results; for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; results.Append(item.Invoke( p1, p2)); } return results; } void Clear(){mItems.Clear();} bool IsEmpty()const { return mItems.IsEmpty(); } const List<DelegateType,EqualCompare<DelegateType> >& GetDelegates() const { return mItems; } public: void operator()( T1 p1, T2 p2)const { Invoke( p1, p2); } void operator+=(const DelegateType& val) { Add(val); } void operator-=(const DelegateType& val) { Remove(val); } Event& operator=(const Event& inEvent) { mItems=inEvent.GetDelegates();return *this; } public: void Add(const DelegateType& val) { if(val.IsValid()){mItems.Append(val);} } void Remove(const DelegateType& val) { mItems.RemoveLast(val); } bool Contains(const DelegateType& val)const { return mItems.Contains(val); } };
template<typename R ,  typename T1, typename T2, typename T3> class Event<R ( T1, T2, T3)> { public: typedef Delegate<R ( T1, T2, T3)> DelegateType; private: List<DelegateType,EqualCompare<DelegateType> > mItems; public: Event(){} Event(const Event& inEvent):mItems(inEvent.mItems){ } public: void Invoke( T1 p1, T2 p2, T3 p3)const { size_t size= mItems.Count(); for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; item.Invoke( p1, p2, p3); } } List<R> InvokeWithResults( T1 p1, T2 p2, T3 p3)const { size_t size= mItems.Count(); List<R> results; for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; results.Append(item.Invoke( p1, p2, p3)); } return results; } void Clear(){mItems.Clear();} bool IsEmpty()const { return mItems.IsEmpty(); } const List<DelegateType,EqualCompare<DelegateType> >& GetDelegates() const { return mItems; } public: void operator()( T1 p1, T2 p2, T3 p3)const { Invoke( p1, p2, p3); } void operator+=(const DelegateType& val) { Add(val); } void operator-=(const DelegateType& val) { Remove(val); } Event& operator=(const Event& inEvent) { mItems=inEvent.GetDelegates();return *this; } public: void Add(const DelegateType& val) { if(val.IsValid()){mItems.Append(val);} } void Remove(const DelegateType& val) { mItems.RemoveLast(val); } bool Contains(const DelegateType& val)const { return mItems.Contains(val); } };
template<typename R ,  typename T1, typename T2, typename T3, typename T4> class Event<R ( T1, T2, T3, T4)> { public: typedef Delegate<R ( T1, T2, T3, T4)> DelegateType; private: List<DelegateType,EqualCompare<DelegateType> > mItems; public: Event(){} Event(const Event& inEvent):mItems(inEvent.mItems){ } public: void Invoke( T1 p1, T2 p2, T3 p3, T4 p4)const { size_t size= mItems.Count(); for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; item.Invoke( p1, p2, p3, p4); } } List<R> InvokeWithResults( T1 p1, T2 p2, T3 p3, T4 p4)const { size_t size= mItems.Count(); List<R> results; for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; results.Append(item.Invoke( p1, p2, p3, p4)); } return results; } void Clear(){mItems.Clear();} bool IsEmpty()const { return mItems.IsEmpty(); } const List<DelegateType,EqualCompare<DelegateType> >& GetDelegates() const { return mItems; } public: void operator()( T1 p1, T2 p2, T3 p3, T4 p4)const { Invoke( p1, p2, p3, p4); } void operator+=(const DelegateType& val) { Add(val); } void operator-=(const DelegateType& val) { Remove(val); } Event& operator=(const Event& inEvent) { mItems=inEvent.GetDelegates();return *this; } public: void Add(const DelegateType& val) { if(val.IsValid()){mItems.Append(val);} } void Remove(const DelegateType& val) { mItems.RemoveLast(val); } bool Contains(const DelegateType& val)const { return mItems.Contains(val); } };
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5> class Event<R ( T1, T2, T3, T4, T5)> { public: typedef Delegate<R ( T1, T2, T3, T4, T5)> DelegateType; private: List<DelegateType,EqualCompare<DelegateType> > mItems; public: Event(){} Event(const Event& inEvent):mItems(inEvent.mItems){ } public: void Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)const { size_t size= mItems.Count(); for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; item.Invoke( p1, p2, p3, p4, p5); } } List<R> InvokeWithResults( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)const { size_t size= mItems.Count(); List<R> results; for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; results.Append(item.Invoke( p1, p2, p3, p4, p5)); } return results; } void Clear(){mItems.Clear();} bool IsEmpty()const { return mItems.IsEmpty(); } const List<DelegateType,EqualCompare<DelegateType> >& GetDelegates() const { return mItems; } public: void operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)const { Invoke( p1, p2, p3, p4, p5); } void operator+=(const DelegateType& val) { Add(val); } void operator-=(const DelegateType& val) { Remove(val); } Event& operator=(const Event& inEvent) { mItems=inEvent.GetDelegates();return *this; } public: void Add(const DelegateType& val) { if(val.IsValid()){mItems.Append(val);} } void Remove(const DelegateType& val) { mItems.RemoveLast(val); } bool Contains(const DelegateType& val)const { return mItems.Contains(val); } };
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> class Event<R ( T1, T2, T3, T4, T5, T6)> { public: typedef Delegate<R ( T1, T2, T3, T4, T5, T6)> DelegateType; private: List<DelegateType,EqualCompare<DelegateType> > mItems; public: Event(){} Event(const Event& inEvent):mItems(inEvent.mItems){ } public: void Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)const { size_t size= mItems.Count(); for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; item.Invoke( p1, p2, p3, p4, p5, p6); } } List<R> InvokeWithResults( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)const { size_t size= mItems.Count(); List<R> results; for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; results.Append(item.Invoke( p1, p2, p3, p4, p5, p6)); } return results; } void Clear(){mItems.Clear();} bool IsEmpty()const { return mItems.IsEmpty(); } const List<DelegateType,EqualCompare<DelegateType> >& GetDelegates() const { return mItems; } public: void operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)const { Invoke( p1, p2, p3, p4, p5, p6); } void operator+=(const DelegateType& val) { Add(val); } void operator-=(const DelegateType& val) { Remove(val); } Event& operator=(const Event& inEvent) { mItems=inEvent.GetDelegates();return *this; } public: void Add(const DelegateType& val) { if(val.IsValid()){mItems.Append(val);} } void Remove(const DelegateType& val) { mItems.RemoveLast(val); } bool Contains(const DelegateType& val)const { return mItems.Contains(val); } };
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> class Event<R ( T1, T2, T3, T4, T5, T6, T7)> { public: typedef Delegate<R ( T1, T2, T3, T4, T5, T6, T7)> DelegateType; private: List<DelegateType,EqualCompare<DelegateType> > mItems; public: Event(){} Event(const Event& inEvent):mItems(inEvent.mItems){ } public: void Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7)const { size_t size= mItems.Count(); for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; item.Invoke( p1, p2, p3, p4, p5, p6, p7); } } List<R> InvokeWithResults( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7)const { size_t size= mItems.Count(); List<R> results; for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; results.Append(item.Invoke( p1, p2, p3, p4, p5, p6, p7)); } return results; } void Clear(){mItems.Clear();} bool IsEmpty()const { return mItems.IsEmpty(); } const List<DelegateType,EqualCompare<DelegateType> >& GetDelegates() const { return mItems; } public: void operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7)const { Invoke( p1, p2, p3, p4, p5, p6, p7); } void operator+=(const DelegateType& val) { Add(val); } void operator-=(const DelegateType& val) { Remove(val); } Event& operator=(const Event& inEvent) { mItems=inEvent.GetDelegates();return *this; } public: void Add(const DelegateType& val) { if(val.IsValid()){mItems.Append(val);} } void Remove(const DelegateType& val) { mItems.RemoveLast(val); } bool Contains(const DelegateType& val)const { return mItems.Contains(val); } };
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> class Event<R ( T1, T2, T3, T4, T5, T6, T7, T8)> { public: typedef Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8)> DelegateType; private: List<DelegateType,EqualCompare<DelegateType> > mItems; public: Event(){} Event(const Event& inEvent):mItems(inEvent.mItems){ } public: void Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8)const { size_t size= mItems.Count(); for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; item.Invoke( p1, p2, p3, p4, p5, p6, p7, p8); } } List<R> InvokeWithResults( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8)const { size_t size= mItems.Count(); List<R> results; for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; results.Append(item.Invoke( p1, p2, p3, p4, p5, p6, p7, p8)); } return results; } void Clear(){mItems.Clear();} bool IsEmpty()const { return mItems.IsEmpty(); } const List<DelegateType,EqualCompare<DelegateType> >& GetDelegates() const { return mItems; } public: void operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8)const { Invoke( p1, p2, p3, p4, p5, p6, p7, p8); } void operator+=(const DelegateType& val) { Add(val); } void operator-=(const DelegateType& val) { Remove(val); } Event& operator=(const Event& inEvent) { mItems=inEvent.GetDelegates();return *this; } public: void Add(const DelegateType& val) { if(val.IsValid()){mItems.Append(val);} } void Remove(const DelegateType& val) { mItems.RemoveLast(val); } bool Contains(const DelegateType& val)const { return mItems.Contains(val); } };
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> class Event<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9)> { public: typedef Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9)> DelegateType; private: List<DelegateType,EqualCompare<DelegateType> > mItems; public: Event(){} Event(const Event& inEvent):mItems(inEvent.mItems){ } public: void Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9)const { size_t size= mItems.Count(); for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; item.Invoke( p1, p2, p3, p4, p5, p6, p7, p8, p9); } } List<R> InvokeWithResults( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9)const { size_t size= mItems.Count(); List<R> results; for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; results.Append(item.Invoke( p1, p2, p3, p4, p5, p6, p7, p8, p9)); } return results; } void Clear(){mItems.Clear();} bool IsEmpty()const { return mItems.IsEmpty(); } const List<DelegateType,EqualCompare<DelegateType> >& GetDelegates() const { return mItems; } public: void operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9)const { Invoke( p1, p2, p3, p4, p5, p6, p7, p8, p9); } void operator+=(const DelegateType& val) { Add(val); } void operator-=(const DelegateType& val) { Remove(val); } Event& operator=(const Event& inEvent) { mItems=inEvent.GetDelegates();return *this; } public: void Add(const DelegateType& val) { if(val.IsValid()){mItems.Append(val);} } void Remove(const DelegateType& val) { mItems.RemoveLast(val); } bool Contains(const DelegateType& val)const { return mItems.Contains(val); } };
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> class Event<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)> { public: typedef Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)> DelegateType; private: List<DelegateType,EqualCompare<DelegateType> > mItems; public: Event(){} Event(const Event& inEvent):mItems(inEvent.mItems){ } public: void Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10)const { size_t size= mItems.Count(); for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; item.Invoke( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } } List<R> InvokeWithResults( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10)const { size_t size= mItems.Count(); List<R> results; for(size_t i=0;i<size;++i) { const DelegateType& item=mItems[i]; results.Append(item.Invoke( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)); } return results; } void Clear(){mItems.Clear();} bool IsEmpty()const { return mItems.IsEmpty(); } const List<DelegateType,EqualCompare<DelegateType> >& GetDelegates() const { return mItems; } public: void operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10)const { Invoke( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } void operator+=(const DelegateType& val) { Add(val); } void operator-=(const DelegateType& val) { Remove(val); } Event& operator=(const Event& inEvent) { mItems=inEvent.GetDelegates();return *this; } public: void Add(const DelegateType& val) { if(val.IsValid()){mItems.Append(val);} } void Remove(const DelegateType& val) { mItems.RemoveLast(val); } bool Contains(const DelegateType& val)const { return mItems.Contains(val); } };
