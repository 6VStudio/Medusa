template<size_t TSize,typename TId, typename TBase   ,bool IsPoolEnabled> class ArrayObjectFactory<TSize,TId,TBase*(),IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback(); typedef CreateDerivedCallback* CreatorType; typedef Stack<TBase*> ObjectPool; ~ArrayObjectFactory(){Clear();} private: CreatorType mMap[TSize]; ObjectPool mPoolMap[TSize]; template<typename TDerived> static TBase* CreateDerivedHelper() { return new TDerived(); } public: template<typename TDerived> void Register(const TId& id){mMap[id]=&CreateDerivedHelper<TDerived>;} void Register(const TId& id,CreatorType creator){mMap[id]=creator;} void UnRegister(const TId& id){mMap[id]=0;} TBase* Create(const TId& id  ) { if(IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];if (!objectPool.IsEmpty()){return objectPool.Pop();}} CreatorType creator=mMap[id]; if (creator!=0) { return (creator)(); } return 0; } void Recycle(const TId& id, TBase* obj) { if (IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];objectPool.Push(obj); } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(size_t i=0;i<TSize;++i) { ObjectPool& objectPool = mPoolMap[i]; {for(auto i = (objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(objectPool).Clear();}; } } };
template<size_t TSize,typename TId, typename TBase ,  typename T1 ,bool IsPoolEnabled> class ArrayObjectFactory<TSize,TId,TBase*( T1 p1),IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1); typedef CreateDerivedCallback* CreatorType; typedef Stack<TBase*> ObjectPool; ~ArrayObjectFactory(){Clear();} private: CreatorType mMap[TSize]; ObjectPool mPoolMap[TSize]; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1) { return new TDerived( p1); } public: template<typename TDerived> void Register(const TId& id){mMap[id]=&CreateDerivedHelper<TDerived>;} void Register(const TId& id,CreatorType creator){mMap[id]=creator;} void UnRegister(const TId& id){mMap[id]=0;} TBase* Create(const TId& id ,  T1 p1) { if(IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];if (!objectPool.IsEmpty()){return objectPool.Pop();}} CreatorType creator=mMap[id]; if (creator!=0) { return (creator)( p1); } return 0; } void Recycle(const TId& id, TBase* obj) { if (IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];objectPool.Push(obj); } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(size_t i=0;i<TSize;++i) { ObjectPool& objectPool = mPoolMap[i]; {for(auto i = (objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(objectPool).Clear();}; } } };
template<size_t TSize,typename TId, typename TBase ,  typename T1, typename T2 ,bool IsPoolEnabled> class ArrayObjectFactory<TSize,TId,TBase*( T1 p1, T2 p2),IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1, T2 p2); typedef CreateDerivedCallback* CreatorType; typedef Stack<TBase*> ObjectPool; ~ArrayObjectFactory(){Clear();} private: CreatorType mMap[TSize]; ObjectPool mPoolMap[TSize]; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1, T2 p2) { return new TDerived( p1, p2); } public: template<typename TDerived> void Register(const TId& id){mMap[id]=&CreateDerivedHelper<TDerived>;} void Register(const TId& id,CreatorType creator){mMap[id]=creator;} void UnRegister(const TId& id){mMap[id]=0;} TBase* Create(const TId& id ,  T1 p1, T2 p2) { if(IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];if (!objectPool.IsEmpty()){return objectPool.Pop();}} CreatorType creator=mMap[id]; if (creator!=0) { return (creator)( p1, p2); } return 0; } void Recycle(const TId& id, TBase* obj) { if (IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];objectPool.Push(obj); } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(size_t i=0;i<TSize;++i) { ObjectPool& objectPool = mPoolMap[i]; {for(auto i = (objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(objectPool).Clear();}; } } };
template<size_t TSize,typename TId, typename TBase ,  typename T1, typename T2, typename T3 ,bool IsPoolEnabled> class ArrayObjectFactory<TSize,TId,TBase*( T1 p1, T2 p2, T3 p3),IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1, T2 p2, T3 p3); typedef CreateDerivedCallback* CreatorType; typedef Stack<TBase*> ObjectPool; ~ArrayObjectFactory(){Clear();} private: CreatorType mMap[TSize]; ObjectPool mPoolMap[TSize]; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1, T2 p2, T3 p3) { return new TDerived( p1, p2, p3); } public: template<typename TDerived> void Register(const TId& id){mMap[id]=&CreateDerivedHelper<TDerived>;} void Register(const TId& id,CreatorType creator){mMap[id]=creator;} void UnRegister(const TId& id){mMap[id]=0;} TBase* Create(const TId& id ,  T1 p1, T2 p2, T3 p3) { if(IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];if (!objectPool.IsEmpty()){return objectPool.Pop();}} CreatorType creator=mMap[id]; if (creator!=0) { return (creator)( p1, p2, p3); } return 0; } void Recycle(const TId& id, TBase* obj) { if (IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];objectPool.Push(obj); } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(size_t i=0;i<TSize;++i) { ObjectPool& objectPool = mPoolMap[i]; {for(auto i = (objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(objectPool).Clear();}; } } };
template<size_t TSize,typename TId, typename TBase ,  typename T1, typename T2, typename T3, typename T4 ,bool IsPoolEnabled> class ArrayObjectFactory<TSize,TId,TBase*( T1 p1, T2 p2, T3 p3, T4 p4),IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1, T2 p2, T3 p3, T4 p4); typedef CreateDerivedCallback* CreatorType; typedef Stack<TBase*> ObjectPool; ~ArrayObjectFactory(){Clear();} private: CreatorType mMap[TSize]; ObjectPool mPoolMap[TSize]; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1, T2 p2, T3 p3, T4 p4) { return new TDerived( p1, p2, p3, p4); } public: template<typename TDerived> void Register(const TId& id){mMap[id]=&CreateDerivedHelper<TDerived>;} void Register(const TId& id,CreatorType creator){mMap[id]=creator;} void UnRegister(const TId& id){mMap[id]=0;} TBase* Create(const TId& id ,  T1 p1, T2 p2, T3 p3, T4 p4) { if(IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];if (!objectPool.IsEmpty()){return objectPool.Pop();}} CreatorType creator=mMap[id]; if (creator!=0) { return (creator)( p1, p2, p3, p4); } return 0; } void Recycle(const TId& id, TBase* obj) { if (IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];objectPool.Push(obj); } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(size_t i=0;i<TSize;++i) { ObjectPool& objectPool = mPoolMap[i]; {for(auto i = (objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(objectPool).Clear();}; } } };
template<size_t TSize,typename TId, typename TBase ,  typename T1, typename T2, typename T3, typename T4, typename T5 ,bool IsPoolEnabled> class ArrayObjectFactory<TSize,TId,TBase*( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5),IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5); typedef CreateDerivedCallback* CreatorType; typedef Stack<TBase*> ObjectPool; ~ArrayObjectFactory(){Clear();} private: CreatorType mMap[TSize]; ObjectPool mPoolMap[TSize]; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5) { return new TDerived( p1, p2, p3, p4, p5); } public: template<typename TDerived> void Register(const TId& id){mMap[id]=&CreateDerivedHelper<TDerived>;} void Register(const TId& id,CreatorType creator){mMap[id]=creator;} void UnRegister(const TId& id){mMap[id]=0;} TBase* Create(const TId& id ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5) { if(IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];if (!objectPool.IsEmpty()){return objectPool.Pop();}} CreatorType creator=mMap[id]; if (creator!=0) { return (creator)( p1, p2, p3, p4, p5); } return 0; } void Recycle(const TId& id, TBase* obj) { if (IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];objectPool.Push(obj); } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(size_t i=0;i<TSize;++i) { ObjectPool& objectPool = mPoolMap[i]; {for(auto i = (objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(objectPool).Clear();}; } } };
template<size_t TSize,typename TId, typename TBase ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6 ,bool IsPoolEnabled> class ArrayObjectFactory<TSize,TId,TBase*( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6),IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6); typedef CreateDerivedCallback* CreatorType; typedef Stack<TBase*> ObjectPool; ~ArrayObjectFactory(){Clear();} private: CreatorType mMap[TSize]; ObjectPool mPoolMap[TSize]; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6) { return new TDerived( p1, p2, p3, p4, p5, p6); } public: template<typename TDerived> void Register(const TId& id){mMap[id]=&CreateDerivedHelper<TDerived>;} void Register(const TId& id,CreatorType creator){mMap[id]=creator;} void UnRegister(const TId& id){mMap[id]=0;} TBase* Create(const TId& id ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6) { if(IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];if (!objectPool.IsEmpty()){return objectPool.Pop();}} CreatorType creator=mMap[id]; if (creator!=0) { return (creator)( p1, p2, p3, p4, p5, p6); } return 0; } void Recycle(const TId& id, TBase* obj) { if (IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];objectPool.Push(obj); } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(size_t i=0;i<TSize;++i) { ObjectPool& objectPool = mPoolMap[i]; {for(auto i = (objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(objectPool).Clear();}; } } };
template<size_t TSize,typename TId, typename TBase ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7 ,bool IsPoolEnabled> class ArrayObjectFactory<TSize,TId,TBase*( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7),IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7); typedef CreateDerivedCallback* CreatorType; typedef Stack<TBase*> ObjectPool; ~ArrayObjectFactory(){Clear();} private: CreatorType mMap[TSize]; ObjectPool mPoolMap[TSize]; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7) { return new TDerived( p1, p2, p3, p4, p5, p6, p7); } public: template<typename TDerived> void Register(const TId& id){mMap[id]=&CreateDerivedHelper<TDerived>;} void Register(const TId& id,CreatorType creator){mMap[id]=creator;} void UnRegister(const TId& id){mMap[id]=0;} TBase* Create(const TId& id ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7) { if(IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];if (!objectPool.IsEmpty()){return objectPool.Pop();}} CreatorType creator=mMap[id]; if (creator!=0) { return (creator)( p1, p2, p3, p4, p5, p6, p7); } return 0; } void Recycle(const TId& id, TBase* obj) { if (IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];objectPool.Push(obj); } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(size_t i=0;i<TSize;++i) { ObjectPool& objectPool = mPoolMap[i]; {for(auto i = (objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(objectPool).Clear();}; } } };
template<size_t TSize,typename TId, typename TBase ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8 ,bool IsPoolEnabled> class ArrayObjectFactory<TSize,TId,TBase*( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8),IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8); typedef CreateDerivedCallback* CreatorType; typedef Stack<TBase*> ObjectPool; ~ArrayObjectFactory(){Clear();} private: CreatorType mMap[TSize]; ObjectPool mPoolMap[TSize]; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8) { return new TDerived( p1, p2, p3, p4, p5, p6, p7, p8); } public: template<typename TDerived> void Register(const TId& id){mMap[id]=&CreateDerivedHelper<TDerived>;} void Register(const TId& id,CreatorType creator){mMap[id]=creator;} void UnRegister(const TId& id){mMap[id]=0;} TBase* Create(const TId& id ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8) { if(IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];if (!objectPool.IsEmpty()){return objectPool.Pop();}} CreatorType creator=mMap[id]; if (creator!=0) { return (creator)( p1, p2, p3, p4, p5, p6, p7, p8); } return 0; } void Recycle(const TId& id, TBase* obj) { if (IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];objectPool.Push(obj); } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(size_t i=0;i<TSize;++i) { ObjectPool& objectPool = mPoolMap[i]; {for(auto i = (objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(objectPool).Clear();}; } } };
template<size_t TSize,typename TId, typename TBase ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9 ,bool IsPoolEnabled> class ArrayObjectFactory<TSize,TId,TBase*( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9),IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9); typedef CreateDerivedCallback* CreatorType; typedef Stack<TBase*> ObjectPool; ~ArrayObjectFactory(){Clear();} private: CreatorType mMap[TSize]; ObjectPool mPoolMap[TSize]; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9) { return new TDerived( p1, p2, p3, p4, p5, p6, p7, p8, p9); } public: template<typename TDerived> void Register(const TId& id){mMap[id]=&CreateDerivedHelper<TDerived>;} void Register(const TId& id,CreatorType creator){mMap[id]=creator;} void UnRegister(const TId& id){mMap[id]=0;} TBase* Create(const TId& id ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9) { if(IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];if (!objectPool.IsEmpty()){return objectPool.Pop();}} CreatorType creator=mMap[id]; if (creator!=0) { return (creator)( p1, p2, p3, p4, p5, p6, p7, p8, p9); } return 0; } void Recycle(const TId& id, TBase* obj) { if (IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];objectPool.Push(obj); } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(size_t i=0;i<TSize;++i) { ObjectPool& objectPool = mPoolMap[i]; {for(auto i = (objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(objectPool).Clear();}; } } };
template<size_t TSize,typename TId, typename TBase ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10 ,bool IsPoolEnabled> class ArrayObjectFactory<TSize,TId,TBase*( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10),IsPoolEnabled> { public: typedef TBase* CreateDerivedCallback( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10); typedef CreateDerivedCallback* CreatorType; typedef Stack<TBase*> ObjectPool; ~ArrayObjectFactory(){Clear();} private: CreatorType mMap[TSize]; ObjectPool mPoolMap[TSize]; template<typename TDerived> static TBase* CreateDerivedHelper( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10) { return new TDerived( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } public: template<typename TDerived> void Register(const TId& id){mMap[id]=&CreateDerivedHelper<TDerived>;} void Register(const TId& id,CreatorType creator){mMap[id]=creator;} void UnRegister(const TId& id){mMap[id]=0;} TBase* Create(const TId& id ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10) { if(IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];if (!objectPool.IsEmpty()){return objectPool.Pop();}} CreatorType creator=mMap[id]; if (creator!=0) { return (creator)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } return 0; } void Recycle(const TId& id, TBase* obj) { if (IsPoolEnabled){ObjectPool& objectPool = mPoolMap[id];objectPool.Push(obj); } else { delete obj; } } void Clear() { if (!IsPoolEnabled){return;} for(size_t i=0;i<TSize;++i) { ObjectPool& objectPool = mPoolMap[i]; {for(auto i = (objectPool).GetEnumerator();i.MoveNext();) {if(*i!=0) { delete *i; *i = 0; };}(objectPool).Clear();}; } } };
